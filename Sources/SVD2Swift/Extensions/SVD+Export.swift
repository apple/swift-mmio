//===----------------------------------------------------------*- swift -*-===//
//
// This source file is part of the Swift MMIO open source project
//
// Copyright (c) 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
//
//===----------------------------------------------------------------------===//

import MMIOUtilities
import SVD

let fileHeader = """
  // Generated by svd2swift.

  import MMIO
  """

struct ExportOptions {
  var indentation: Indentation
  var accessLevel: AccessLevel?
  var selectedPeripherals: [String]
  var namespaceUnderDevice: Bool
  var instanceMemberPeripherals: Bool
  var overrideDeviceName: String?
}

struct ExportContext {
  var types: [any SVDExportable]
  var swiftTypeName: String
  var swiftDescription: String
  var swiftInstanceName: String
  var swiftParentTypeNames: [String]
  var registerProperties: SVDRegisterProperties
}

extension ExportContext {
  var swiftParentTypeFullName: String? {
    guard !self.swiftParentTypeNames.isEmpty else { return nil }
    return self.swiftParentTypeNames.joined(separator: ".")
  }

  init() {
    self.types = []
    self.swiftTypeName = ""
    self.swiftDescription = ""
    self.swiftInstanceName = ""
    self.swiftParentTypeNames = []
    self.registerProperties = .none
  }

  func childContext(for exportable: SVDExportable) -> Self {
    let swiftTypeName = exportable.swiftTypeName(context: self)
    let swiftDescription = exportable.swiftDescription(
      swiftTypeName: swiftTypeName)
    let swiftInstanceName = swiftTypeName.lowercased()
    let registerProperties = exportable
      .registerProperties
      .merging(self.registerProperties)

    return .init(
      types: [],
      swiftTypeName: swiftTypeName,
      swiftDescription: swiftDescription,
      swiftInstanceName: swiftInstanceName,
      swiftParentTypeNames: self.swiftParentTypeNames,
      registerProperties: registerProperties)
  }

  func asParentContext() -> Self {
    var copy = self
    copy.swiftTypeName = ""
    copy.swiftDescription = ""
    copy.swiftInstanceName = ""
    if self.swiftTypeName != "" {
      copy.swiftParentTypeNames.append(self.swiftTypeName)
    }
    return copy
  }
}

extension SVDDevice {
  func export(
    with options: ExportOptions,
    to output: inout Output
  ) throws {
    var outputWriter = OutputWriter(
      output: output,
      indentation: options.indentation)
    defer { output = outputWriter.output }
    try self.export(outputWriter: &outputWriter, options: options)
  }

  fileprivate func export(
    outputWriter: inout OutputWriter,
    options: ExportOptions
  ) throws {

    let rootContext = ExportContext()
    var deviceContext = rootContext.asParentContext().childContext(for: self)
    if let deviceName = options.overrideDeviceName {
      deviceContext.swiftTypeName = deviceName
      deviceContext.swiftInstanceName = deviceName.lowercased()
    }

    outputWriter.insert(fileHeader)
    let childTypes = try self.exportType(
      outputWriter: &outputWriter,
      options: options,
      context: deviceContext)
    try outputWriter.flush(to: "Device.swift")

    for peripheral in childTypes {
      outputWriter.insert(fileHeader)

      if options.namespaceUnderDevice {
        deviceContext = deviceContext.asParentContext()
      }

      var peripheralContext = deviceContext.childContext(for: peripheral)
      peripheralContext.types = [peripheral]

      // Track indices instead of popping front to avoid O(N) pop. This bloats
      // memory usage, but hopefully is not an issue in practice. We can adopt
      // `Deque` if needed in the future.
      var exportQueue = [peripheralContext]
      var currentIndex = exportQueue.startIndex
      while currentIndex < exportQueue.endIndex {
        defer { exportQueue.formIndex(after: &currentIndex) }

        let currentContext = exportQueue[currentIndex]

        // This is a hack to move the generated BitFieldProjectable one scope
        // higher, from out of the field type generated by the BitField macro
        // and into the register type generated by SVD2Swift.
        var scopeContext = currentContext
        let childIsEnumeratedValue =
          scopeContext.types.count == 1
          && currentContext.types[0] is SVDEnumeration
        if childIsEnumeratedValue {
          scopeContext.swiftParentTypeNames.removeLast()
        }

        let scope =
          if let name = scopeContext.swiftParentTypeFullName {
            "extension \(name)"
          } else {
            ""
          }

        try outputWriter.scope(scope, lazy: true) { outputWriter in
          for child in currentContext.types {
            var childContext = currentContext.childContext(for: child)

            let subchildTypes = try child.exportType(
              outputWriter: &outputWriter,
              options: options,
              context: childContext)

            if !subchildTypes.isEmpty {
              childContext.types = subchildTypes
              exportQueue.append(childContext.asParentContext())
            }
          }
        }
      }

      try outputWriter.flush(
        to: "\(peripheralContext.swiftTypeName).swift")
    }
  }
}

protocol SVDExportable {
  var registerProperties: SVDRegisterProperties { get }

  func swiftTypeName(context: ExportContext) -> String
  func swiftDescription(swiftTypeName: String) -> String

  func exportType(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext
  ) throws -> [any SVDExportable]

  func exportAccessor(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext)
}

extension SVDDevice: SVDExportable {
  func swiftTypeName(context: ExportContext) -> String {
    self.name.removingUnsafeCharacters()
  }

  func swiftDescription(swiftTypeName: String) -> String {
    self.description?.coalescingConsecutiveSpaces() ?? swiftTypeName
  }

  func outputPeripherals(
    options: ExportOptions
  ) throws -> [SVDPeripheral] {
    var outputPeripherals = [SVDPeripheral]()
    if options.selectedPeripherals.isEmpty {
      outputPeripherals = self.peripherals.peripheral
    } else {
      var peripheralsByName = [String: SVDPeripheral]()
      for peripheral in self.peripherals.peripheral {
        peripheralsByName[peripheral.name] = peripheral
      }
      for selectedPeripheral in options.selectedPeripherals {
        guard let peripheral = peripheralsByName[selectedPeripheral] else {
          throw SVD2SwiftError.unknownPeripheral(
            selectedPeripheral, self.peripherals.peripheral.map(\.name))
        }
        outputPeripherals.append(peripheral)
      }
    }
    outputPeripherals = outputPeripherals.sorted { $0.name < $1.name }
    return outputPeripherals
  }

  func exportType(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext
  ) throws -> [any SVDExportable] {
    let outputPeripherals = try self.outputPeripherals(options: options)

    let deviceDeclarationType =
      if options.instanceMemberPeripherals {
        "struct"
      } else {
        "enum"
      }

    let scope =
      if options.namespaceUnderDevice {
        """
        \(comment: context.swiftDescription)
        \(options.accessLevel)\(deviceDeclarationType) \(context.swiftTypeName)
        """
      } else {
        ""
      }

    outputWriter.scope(scope) { outputWriter in
      for peripheral in outputPeripherals {
        peripheral.exportAccessor(
          outputWriter: &outputWriter,
          options: options,
          context: context.asParentContext().childContext(for: peripheral))
      }
    }

    return outputPeripherals
  }

  func exportAccessor(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext
  ) {}
}

extension SVDPeripheral: SVDExportable {
  func swiftTypeName(context: ExportContext) -> String {
    self.name.removingUnsafeCharacters()
  }

  func swiftDescription(swiftTypeName: String) -> String {
    self.description?.coalescingConsecutiveSpaces() ?? swiftTypeName
  }

  func exportType(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext
  ) -> [any SVDExportable] {
    var exports = [any SVDExportable]()
    if let derivedFrom = self.derivedFrom {
      // FIXME: Handle only exporting B where B deriveFrom A
      outputWriter.insert(
        """
        \(comment: context.swiftDescription)
        \(options.accessLevel)typealias \(context.swiftTypeName) = \(derivedFrom)

        """)
    } else {
      let scope = """
        \(comment: context.swiftDescription)
        @RegisterBlock
        \(options.accessLevel)struct \(context.swiftTypeName)
        """

      outputWriter.scope(scope) { outputWriter in
        guard let registersAndClusters = self.registers else { return }

        for register in registersAndClusters.register {
          register.exportAccessor(
            outputWriter: &outputWriter,
            options: options,
            context: context.asParentContext().childContext(for: register))
          exports.append(register)
        }

        for cluster in registersAndClusters.cluster {
          cluster.exportAccessor(
            outputWriter: &outputWriter,
            options: options,
            context: context.asParentContext().childContext(for: cluster))
          exports.append(cluster)
        }
      }
    }

    return exports
  }

  func exportAccessor(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext
  ) {
    let accessorModifier =
      if options.namespaceUnderDevice && !options.instanceMemberPeripherals {
        "static "
      } else {
        ""
      }

    if let dimensionElement = self.dimensionElement {
      let count = dimensionElement.dim
      let stride = dimensionElement.dimIncrement

      outputWriter.insert(
        """
        \(comment: context.swiftDescription)
        \(options.accessLevel)\(accessorModifier)let \(identifier: context.swiftInstanceName) = RegisterArray<\(context.swiftTypeName)>(\
        unsafeAddress: \(hex: self.baseAddress), stride: \(hex: stride), count: \(count))
        """)
    } else {
      outputWriter.insert(
        """
        \(comment: context.swiftDescription)
        \(options.accessLevel)\(accessorModifier)let \(identifier: context.swiftInstanceName) = \(context.swiftTypeName)(unsafeAddress: \(hex: self.baseAddress))
        """)
    }
  }
}

extension SVDCluster: SVDExportable {
  func swiftTypeName(context: ExportContext) -> String {
    self.name.removingUnsafeCharacters()
  }

  func swiftDescription(swiftTypeName: String) -> String {
    self.description.coalescingConsecutiveSpaces()
  }

  func exportAccessor(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext
  ) {
    if let dimensionElement = self.dimensionElement {
      let count = dimensionElement.dim
      let stride = dimensionElement.dimIncrement

      outputWriter.insert(
        """
        \(comment: context.swiftDescription)
        @RegisterBlock(offset: \(hex: self.addressOffset), stride: \(hex: stride), count: \(count))
        \(options.accessLevel)var \(identifier: context.swiftInstanceName): RegisterArray<\(context.swiftTypeName)>
        """)
    } else {
      outputWriter.insert(
        """
        \(comment: context.swiftDescription)
        @RegisterBlock(offset: \(hex: self.addressOffset))
        \(options.accessLevel)var \(identifier: context.swiftInstanceName): \(context.swiftTypeName)
        """)
    }
  }

  func exportType(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext
  ) -> [any SVDExportable] {
    var exports = [any SVDExportable]()

    if let derivedFrom = self.derivedFrom {
      outputWriter.insert(
        """
        \(comment: context.swiftDescription)
        \(options.accessLevel)typealias \(context.swiftTypeName) = \(derivedFrom)

        """)
    } else {

      let scope = """
        \(comment: context.swiftDescription)
        @RegisterBlock
        \(options.accessLevel)struct \(context.swiftTypeName)
        """

      outputWriter.scope(scope) { outputWriter in
        if let registers = self.register {
          for register in registers {
            register.exportAccessor(
              outputWriter: &outputWriter,
              options: options,
              context: context.asParentContext().childContext(for: register))
            exports.append(register)
          }
        }

        if let clusters = self.cluster {
          for cluster in clusters {
            cluster.exportAccessor(
              outputWriter: &outputWriter,
              options: options,
              context: context.asParentContext().childContext(for: cluster))
            exports.append(cluster)
          }
        }
      }
    }
    return exports
  }
}

extension SVDRegister: SVDExportable {
  func swiftTypeName(context: ExportContext) -> String {
    self.name.removingUnsafeCharacters()
  }

  func swiftDescription(swiftTypeName: String) -> String {
    self.description?.coalescingConsecutiveSpaces() ?? swiftTypeName
  }

  func exportAccessor(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext
  ) {
    if let dimensionElement = self.dimensionElement {
      let count = dimensionElement.dim
      let stride = dimensionElement.dimIncrement

      outputWriter.insert(
        """
        \(comment: context.swiftDescription)
        @RegisterBlock(offset: \(hex: self.addressOffset), stride: \(hex: stride), count: \(count))
        \(options.accessLevel)var \(identifier: context.swiftInstanceName): RegisterArray<\(context.swiftTypeName)>
        """)
    } else {
      outputWriter.insert(
        """
        \(comment: context.swiftDescription)
        @RegisterBlock(offset: \(hex: self.addressOffset))
        \(options.accessLevel)var \(identifier: context.swiftInstanceName): Register<\(context.swiftTypeName)>
        """)
    }
  }

  func exportType(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext
  ) -> [any SVDExportable] {
    guard let size = context.registerProperties.size else {
      // FIXME: warning diagnostic
      print(
        """
        warning: skipped exporting \(context.swiftTypeName): unknown register size

        """)
      return []
    }

    var exports = [any SVDExportable]()

    let scope = """
      \(comment: context.swiftDescription)
      @Register(bitWidth: \(size))
      \(options.accessLevel)struct \(context.swiftTypeName)
      """
    outputWriter.scope(scope) { outputWriter in
      let fields = self.fields?.field ?? []
      for field in fields {
        field.exportAccessor(
          outputWriter: &outputWriter,
          options: options,
          context: context.asParentContext().childContext(for: field))
        exports.append(field)
      }
    }

    return exports
  }
}

extension SVDField: SVDExportable {
  var registerProperties: SVDRegisterProperties {
    // We abuse "size" here to be field size instead of register size
    .init(size: UInt64(self.bitRange.range.count))
  }

  func swiftTypeName(context: ExportContext) -> String {
    // Remove unsafe characters from the name.
    var name = self.name.removingUnsafeCharacters()

    // If the name of this field is the same as the parent register, suffix the
    // field name with "_FIELD". This is based on the **assumption** that no
    // other field in the register already has the new name.
    if name == context.swiftParentTypeNames.last {
      name += "_FIELD"
    }

    // If the field's name is all lowercase then the generated type and
    // property will collide. In this case we uppercase the name of the field to
    // avoid the collision.
    if name == name.lowercased() {
      name = name.uppercased()
    }

    return name
  }

  func swiftDescription(swiftTypeName: String) -> String {
    self.description?.coalescingConsecutiveSpaces() ?? swiftTypeName
  }

  func childTypes() -> [any SVDExportable] {
    if let enumeration = self.enumeratedValues {
      let usage = enumeration.usage ?? .readWrite
      // FIXME: support read / insert only projections
      // FIXME: support derivedFrom
      if usage == .readWrite {
        return [enumeration]
      }
    }
    return []
  }

  func exportType(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext
  ) -> [any SVDExportable] {
    self.childTypes()
  }

  func exportAccessor(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext
  ) {
    let macro =
      switch self.access ?? context.registerProperties.access {
      case .readOnly: "ReadOnly"
      case .writeOnly: "WriteOnly"
      case .readWrite: "ReadWrite"
      // FIXME: How to express in Swift?
      case .writeOnce: "WriteOnly"
      // FIXME: How to express in Swift?
      case .readWriteOnce: "ReadWrite"
      // FIXME: emit diagnostic about unknown -> reserved
      case nil: "Reserved"
      }

    var enumeration: SVDEnumeration?
    if let enumeratedValues = self.enumeratedValues {
      let usage = enumeratedValues.usage ?? .readWrite
      // FIXME: support read / insert only projections
      // FIXME: support derivedFrom
      if usage == .readWrite {
        enumeration = enumeratedValues
      }
    }

    func _projection() -> String {
      guard let enumeration = enumeration else { return "" }
      let name = enumeration.swiftTypeName(
        context: context.asParentContext().childContext(for: enumeration))
      return ", as: \(name).self"
    }

    let range = self.bitRange.range
    if let dimensionElement = self.dimensionElement {
      let count = dimensionElement.dim
      let stride = dimensionElement.dimIncrement

      // FIXME: array fields
      // Instead of splatting out N copies of the field we should have some way
      // to describe an array like RegisterArray
      for index in 0..<count {
        let bitOffset = stride * index
        outputWriter.insert(
          """
          \(comment: context.swiftDescription)
          @\(macro)(bits: \(range.lowerBound + bitOffset)..<\(range.upperBound + bitOffset)\(_projection()))
          \(options.accessLevel)var \(identifier: "\(context.swiftInstanceName)\(index)"): \(context.swiftTypeName)\(index)
          """)
      }
    } else {
      outputWriter.insert(
        """
        \(comment: context.swiftDescription)
        @\(macro)(bits: \(range.lowerBound)..<\(range.upperBound)\(_projection()))
        \(options.accessLevel)var \(identifier: context.swiftInstanceName): \(context.swiftTypeName)
        """)
    }
  }
}

extension SVDEnumeration: SVDExportable {
  var registerProperties: SVDRegisterProperties { .none }

  func swiftTypeName(context: ExportContext) -> String {
    var name =
      self.name?.removingUnsafeCharacters()
      ?? context.swiftParentTypeNames.last.map { "\($0)Values" }
      ?? "Unknown"
    if name == context.swiftParentTypeNames.last {
      name.append("Values")
    }
    return name
  }

  func swiftDescription(swiftTypeName: String) -> String { "" }

  func exportType(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext
  ) -> [any SVDExportable] {

    let bitWidth = context.registerProperties.size ?? 0
    let rawValueWidth = max(8, bitWidth.roundedUpToPowerOfTwo())
    let rawValueType = "UInt\(rawValueWidth)"

    let requiresPattern = self.enumeratedValue.contains {
      guard case .value(let value) = $0.data else { return false }
      return value.value.mask != .max
    }

    let typeScope = """
      \(options.accessLevel)struct \(context.swiftTypeName): BitFieldProjectable, RawRepresentable
      """
    outputWriter.scope(typeScope) { outputWriter in
      outputWriter.insert(
        """
        \(options.accessLevel)static let bitWidth = \(bitWidth)
        """)

      if requiresPattern {
        let patternScope = "\(options.accessLevel)struct Pattern"
        outputWriter.scope(patternScope) { outputWriter in
          outputWriter.insert(
            """
            var rawValue: UInt8
            var mask: UInt8
            """)
        }

        let patternMatchScope = """
          \(options.accessLevel)static func ~= (pattern: Pattern, value: Self) -> Bool
          """
        outputWriter.scope(patternMatchScope) { outputWriter in
          outputWriter.insert(
            """
            (value.rawValue & pattern.mask) == pattern.rawValue
            """)
        }
      }

      for enumeratedValue in self.enumeratedValue {
        switch enumeratedValue.data {
        case .value(let value):
          var swiftName =
            enumeratedValue.name
            ?? value.value.description(bitWidth: Int(bitWidth))
          let swiftDescription = enumeratedValue.description ?? swiftName
          swiftName = swiftName.removingUnsafeCharacters()
          if swiftName.first?.isLetter == false {
            swiftName.insert("_", at: swiftName.startIndex)
          }

          let mask = value.value.mask
          let value = value.value.value

          switch mask {
          case .max:
            // All bits specified
            outputWriter.insert(
              """
              \(comment: swiftDescription)
              \(options.accessLevel)static let \(swiftName) = Self(rawValue: \(hex: value))
              """)

          default:
            outputWriter.insert(
              """
              \(comment: swiftDescription)
              \(options.accessLevel)static let \(swiftName) = Pattern(rawValue: \(hex: value), mask: \(hex: mask, bits: bitWidth))
              """)

            let factoryScope = """
              \(comment: swiftDescription)
              \(options.accessLevel)static func \(swiftName)(_ rawValue: \(rawValueType) = \(swiftName).value) -> Self
              """
            outputWriter.scope(factoryScope) { outputWriter in
              outputWriter.insert(
                """
                let value = Self(rawValue: rawValue)
                precondition(\(swiftName) ~= \(value), "Invalid bits set in rawValue")
                return value
                """)
            }
          }

        case .isDefault:
          print("warning: ignored for now...")
        }
      }

      outputWriter.insert(
        """
        \(options.accessLevel)var rawValue: \(rawValueType)
        """)

      let initScope = """
        @inlinable @inline(__always)
        \(options.accessLevel)init(rawValue: Self.RawValue)
        """
      outputWriter.scope(initScope) { outputWriter in
        outputWriter.insert("self.rawValue = rawValue")
      }
    }

    return []
  }

  func exportAccessor(
    outputWriter: inout OutputWriter,
    options: ExportOptions,
    context: ExportContext
  ) {}
}
