//===----------------------------------------------------------*- swift -*-===//
//
// This source file is part of the Swift MMIO open source project
//
// Copyright (c) 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
//
//===----------------------------------------------------------------------===//

// Explore bit field refactor:
// * requires variadic pack iteration
// * requires metadata-less variadic packs
// - protocol BitField with (least|most) significant bit requirements
// - FixedWidthInteger.subscript[(variadic T: BitField)] -> Storage

/// A protocol representing a logical field within a hardware register.
///
/// `BitField` provides a common interface for extracting a field's value from
/// and inserting it into a register's raw storage. It also defines
/// interactions with ``BitFieldProjectable`` types, allowing fields to be
/// represented by more expressive Swift types.
///
/// - Note: This protocol is primarily an internal abstraction used by code
///   generated by Swift MMIO's bit field macros (e.g., ``ReadWrite(bits:as:)``,
///   ``ReadOnly(bits:as:)``, etc.). You typically do not need to conform types
///   to `BitField` directly.
///
/// The behavior of a bit field is further specialized by protocols like
/// ``ContiguousBitField`` for fields occupying a single range of bits, and
/// ``DiscontiguousBitField`` for fields spread across multiple segments.
public protocol BitField {
  /// The underlying integer type of the register this bit field belongs to.
  ///
  /// This type must conform to `FixedWidthInteger` and `UnsignedInteger`,
  /// representing the raw storage of the register (e.g., `UInt32`).
  associatedtype Storage: FixedWidthInteger & UnsignedInteger
  /// The type this bit field projects to, if a type projection is specified.
  ///
  /// If no projection (e.g., `as: SomeType.self` in a bit field macro) is used,
  /// this defaults to `Never`. Otherwise, it's the custom type (like `Bool` or
  // an enum) that must conform to ``BitFieldProjectable``.
  associatedtype Projection: BitFieldProjectable

  /// The total width of this logical bit field, in bits.
  ///
  /// For a ``ContiguousBitField``, this is the number of bits in its
  /// `bitRange`. For a ``DiscontiguousBitField``, this is the sum of the widths
  /// of all its constituent bit segments.
  static var bitWidth: Int { get }

  /// Inserts the bit field's raw `value` into the `storage` of a register.
  ///
  /// This method takes a `value` representing the data for this bit field (already
  /// masked to fit within `Self.bitWidth`) and places it into the correct
  /// bit positions within the `inout storage` parameter, which represents the
  /// entire register's raw value.
  ///
  /// - Parameters:
  ///   - value: The raw integer value for this bit field.
  ///   - storage: An `inout` parameter representing the register's
  ///     raw value, which is modified in place.
  static func insertBits(_ value: Storage, into storage: inout Storage)

  /// Extracts the raw integer value of this bit field from a register's `storage`.
  ///
  /// This method reads the appropriate bits from the `storage` (the entire
  /// register's raw value), right-aligns them (so the LSB of the field is at
  /// bit 0 of the returned value), and masks the result to `Self.bitWidth`.
  ///
  /// - Parameter storage: The entire register's raw value.
  /// - Returns: The raw integer value of this bit field.
  static func extractBits(from storage: Storage) -> Storage

  /// Inserts a projected value into the register's `storage`.
  ///
  /// This method converts the given `value` of `Projection` type into its raw
  /// `Storage` representation using ``BitFieldProjectable/storage(_:)``,
  /// and then uses ``insertBits(_:into:)`` to place it in the `storage`.
  ///
  /// - Precondition: `Self.bitWidth` must equal `Projection.bitWidth`.
  ///   A mismatch indicates an invalid projection and causes a runtime trap.
  /// - Parameters:
  ///   - value: The projected value to insert.
  ///   - storage: An `inout` parameter for the register's raw value.
  static func insert(_ value: Projection, into storage: inout Storage)

  /// Extracts a projected value from the register's `storage`.
  ///
  /// This method first calls ``extractBits(from:)`` to get the raw integer
  /// value of the field, then initializes an instance of the `Projection` type
  /// using ``BitFieldProjectable/init(storage:)``.
  ///
  /// - Precondition: `Self.bitWidth` must equal `Projection.bitWidth`.
  ///   A mismatch indicates an invalid projection and causes a runtime trap.
  /// - Parameter storage: The register's raw value.
  /// - Returns: An instance of the `Projection` type.
  static func extract(from storage: Storage) -> Projection
}

// Default implementations for insert/extract for Projection
extension BitField {
  @inlinable @inline(__always)
  static func preconditionMatchingBitWidth(
    file: StaticString = #file,
    line: UInt = #line
  ) {
    #if hasFeature(Embedded)
    // FIXME: Embedded doesn't have static interpolated strings yet
    precondition(
      Self.bitWidth == Projection.bitWidth,
      "Illegal projection of bit-field as type of differing bit-width",
      file: file,
      line: line)
    #else
    precondition(
      Self.bitWidth == Projection.bitWidth,
      """
      Illegal projection of \(Self.bitWidth) bit bit-field '\(Self.self)' \
      as \(Projection.bitWidth) bit type '\(Projection.self)'
      """,
      file: file,
      line: line)
    #endif
  }

  @inlinable @inline(__always)
  public static func insert(_ value: Projection, into storage: inout Storage) {
    Self.preconditionMatchingBitWidth()
    Self.insertBits(value.storage(Storage.self), into: &storage)
  }

  @inlinable @inline(__always)
  public static func extract(from storage: Self.Storage) -> Projection {
    Self.preconditionMatchingBitWidth()
    return Projection(storage: Self.extractBits(from: storage))
  }
}

/// A protocol for bit fields that occupy a single, contiguous range of bits
/// within a register.
///
/// - Note: This is an internal detail; types conforming to this are generated
///   by macros like ``ReadWrite(bits:as:)`` when a single range is specified.
public protocol ContiguousBitField: BitField {
  /// The range of bits this field occupies within the register (e.g., `0..<4`
  /// for bits 0, 1, 2, 3).
  static var bitRange: Range<Int> { get }
  /// The offset of this field, representing the position of its least
  /// significant bit (LSB).
  ///
  /// This is derived from `bitRange.lowerBound`.
  static var bitOffset: Int { get }
  /// A bitmask representing the width of this field, right-aligned.
  /// For a field of `N` bits, this mask is `(1 << N) - 1`.
  /// This is derived from `bitWidth`.
  static var bitMask: Storage { get }
}

// Default implementations for ContiguousBitField
extension ContiguousBitField {
  @inlinable @inline(__always)
  public static var bitWidth: Int {
    Self.bitRange.upperBound - Self.bitRange.lowerBound
  }

  @inlinable @inline(__always)
  public static var bitOffset: Int { Self.bitRange.lowerBound }

  @inlinable @inline(__always)
  public static var bitMask: Storage { (1 << Self.bitWidth) &- 1 }

  // FIXME: value.bitWidth <= Self.bitWidth <= Storage.bitWidth
  @inlinable @inline(__always)
  public static func insertBits(_ value: Storage, into storage: inout Storage) {
    storage[bits: Self.bitRange] = value
  }

  @inlinable @inline(__always)
  public static func extractBits(from storage: Storage) -> Storage {
    storage[bits: Self.bitRange]
  }
}

/// A protocol for bit fields that are composed of multiple, non-adjacent
/// (discontiguous) segments of bits within a register.
///
/// - Note: This is an internal detail; types conforming to this are generated
///   by macros like ``ReadWrite(bits:as:)`` when multiple ranges are specified.
public protocol DiscontiguousBitField: BitField {
  /// An array of bit ranges that make up this logical field.
  ///
  /// - Precondition: Bit bitRanges must not overlap and must be sorted by from
  /// lowest to highest bit index
  static var bitRanges: [Range<Int>] { get }
}

// Default implementations for DiscontiguousBitField
extension DiscontiguousBitField {
  @inlinable @inline(__always)
  public static var bitWidth: Int {
    var bitWidth = 0
    for bitRange in Self.bitRanges {
      bitWidth += bitRange.upperBound - bitRange.lowerBound
    }
    return bitWidth
  }

  @inlinable @inline(__always)
  public static func insertBits(_ value: Storage, into storage: inout Storage) {
    storage[bits: Self.bitRanges] = value
  }

  @inlinable @inline(__always)
  public static func extractBits(from storage: Storage) -> Storage {
    storage[bits: Self.bitRanges]
  }
}
